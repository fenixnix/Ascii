shader_type canvas_item;

uniform vec2 resolution = vec2(1024.);

vec3 fade(vec3 x) { return x * x * x * (x * (x * 6. - 15.) + 10.); }

vec3 phash(vec3 p)
{
    p = fract(mat3(vec3(1.2989833, 7.8233198, 2.3562332),
                   vec3(6.7598192, 3.4857334, 8.2837193),
                   vec3(2.9175399, 2.9884245, 5.4987265)) * p);
    p = ((2384.2345 * p - 1324.3438) * p + 3884.2243) * p - 4921.2354;
    return normalize(fract(p) * 2. - 1.);
}

float noise(vec3 p)
{
    vec3 ip = floor(p);
    vec3 fp = fract(p);
    float d000 = dot(phash(ip), fp);
    float d001 = dot(phash(ip + vec3(0, 0, 1)), fp - vec3(0, 0, 1));
    float d010 = dot(phash(ip + vec3(0, 1, 0)), fp - vec3(0, 1, 0));
    float d011 = dot(phash(ip + vec3(0, 1, 1)), fp - vec3(0, 1, 1));
    float d100 = dot(phash(ip + vec3(1, 0, 0)), fp - vec3(1, 0, 0));
    float d101 = dot(phash(ip + vec3(1, 0, 1)), fp - vec3(1, 0, 1));
    float d110 = dot(phash(ip + vec3(1, 1, 0)), fp - vec3(1, 1, 0));
    float d111 = dot(phash(ip + vec3(1, 1, 1)), fp - vec3(1, 1, 1));
    fp = fade(fp);
    return mix(mix(mix(d000, d001, fp.z), mix(d010, d011, fp.z), fp.y),
               mix(mix(d100, d101, fp.z), mix(d110, d111, fp.z), fp.y), fp.x);
}

void fragment()
{
    vec3 p = vec3(FRAGCOORD.xy * 10. / resolution.y, TIME);
    COLOR = vec4(noise(p) / 2. + 0.5);
}
